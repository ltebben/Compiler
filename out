i64
i64
double
[256 x i8]
i64
i64
double
[256 x i8]
double
expanding program
expanding program header
returning: (Keyword,program)
returning: (Identifier,test_program)
returning: (Keyword,is)
expanding program body
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,i)
returning: (Colon,:)
expanding type mark
returning: (Keyword,float)
returning: (Semicolon,;)
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,res)
returning: (Colon,:)
expanding type mark
returning: (Keyword,float)
returning: (Semicolon,;)
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,out)
returning: (Colon,:)
expanding type mark
returning: (Keyword,bool)
returning: (Semicolon,;)
returning: (Keyword,begin)
MOVING ON TO PROGRAM CODE FINALLY
returning: (Identifier,i)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Digit,144.0)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Digit', '144.0')
144.0
VAL IN FACTOR double 0x4062000000000000
acceptable: digit
type in factor: float
AT THE END OF FACTOR, val= 
double 0x4062000000000000
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: float
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'double (double)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (double)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'double (double)*'>}}, {'i': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'i' of type 'double*', opname 'alloca', operands ()>}, 'res': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'res' of type 'double*', opname 'alloca', operands ()>}, 'out': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'out' of type 'i64*', opname 'alloca', operands ()>}}]
%"i" = alloca double
Back in program body, tmp is ('Semicolon', ';')
returning: (Identifier,res)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,sqrt)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'sqrt')
name or procedure call?
expanding name or procedure
('Identifier', 'sqrt')
returning: (Paren,()
expanding procedure call
in expand procedure call:  ('Paren', '(')
returning: (Identifier,i)
expanding argument list
expanding expression
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'i')
name or procedure call?
expanding name or procedure
('Identifier', 'i')
returning: (Paren,))
expanding name
{'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'i' of type 'double*', opname 'alloca', operands ()>}
type in name_or_procedure: float
type in factor: float
AT THE END OF FACTOR, val= 
%".3" = load double, double* %"i"
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
val in argument list after expression ('Paren', ')')
Here I am right before the die
type in name_or_procedure: float
type in factor: float
AT THE END OF FACTOR, val= 
%".4" = call double @"sqrt"(double %".3")
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: float
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'double (double)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (double)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'double (double)*'>}}, {'i': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'i' of type 'double*', opname 'alloca', operands ()>}, 'res': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'res' of type 'double*', opname 'alloca', operands ()>}, 'out': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'out' of type 'i64*', opname 'alloca', operands ()>}}]
%"res" = alloca double
Back in program body, tmp is ('Semicolon', ';')
returning: (Identifier,out)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,putfloat)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'putfloat')
name or procedure call?
expanding name or procedure
('Identifier', 'putfloat')
returning: (Paren,()
expanding procedure call
in expand procedure call:  ('Paren', '(')
returning: (Identifier,res)
expanding argument list
expanding expression
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'res')
name or procedure call?
expanding name or procedure
('Identifier', 'res')
returning: (Paren,))
expanding name
{'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'res' of type 'double*', opname 'alloca', operands ()>}
type in name_or_procedure: float
type in factor: float
AT THE END OF FACTOR, val= 
%".6" = load double, double* %"res"
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
val in argument list after expression ('Paren', ')')
Here I am right before the die
type in name_or_procedure: bool
type in factor: bool
AT THE END OF FACTOR, val= 
%".7" = call i64 @"putfloat"(double %".6")
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: bool
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'double (double)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (double)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'double (double)*'>}}, {'i': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'i' of type 'double*', opname 'alloca', operands ()>}, 'res': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'res' of type 'double*', opname 'alloca', operands ()>}, 'out': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'out' of type 'i64*', opname 'alloca', operands ()>}}]
%"out" = alloca i64
Back in program body, tmp is ('Semicolon', ';')
returning: (Keyword,end)
returning: (Keyword,program)
returning: (Period,.)
returning: (EOF,eof)
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'double (double)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (double)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'double (double)*'>}}, {'i': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'i' of type 'double*', opname 'alloca', operands ()>}, 'res': {'type': 'float', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'res' of type 'double*', opname 'alloca', operands ()>}, 'out': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'out' of type 'i64*', opname 'alloca', operands ()>}}]
; ModuleID = "program"
target triple = "unknown-unknown-unknown"
target datalayout = ""

declare i64 @"getbool"(i64 %".1") 

declare i64 @"getinteger"(i64 %".1") 

declare double @"getfloat"(double %".1") 

declare [256 x i8] @"getstring"([256 x i8] %".1") 

declare i64 @"putbool"(i64 %".1") 

declare i64 @"putinteger"(i64 %".1") 

declare i64 @"putfloat"(double %".1") 

declare i64 @"putstring"([256 x i8] %".1") 

declare double @"sqrt"(double %".1") 

define i64 @"main_function"() 
{
main_entry:
  %"i" = alloca double
  %"res" = alloca double
  %"out" = alloca i64
  store double 0x4062000000000000, double* %"i"
  %".3" = load double, double* %"i"
  %".4" = call double @"sqrt"(double %".3")
  store double %".4", double* %"res"
  %".6" = load double, double* %"res"
  %".7" = call i64 @"putfloat"(double %".6")
  store i64 %".7", i64* %"out"
  ret i64 1
}

RES: 1
12.000000
