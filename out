[]
declare i64 @"getbool"() 

[]
declare i64 @"getinteger"() 

[]
declare double @"getfloat"() 

(<<class 'llvmlite.ir.types.PointerType'> [256 x i8]*>,)
declare [256 x i8] @"getstring"([256 x i8]* %".1") 

(<<class 'llvmlite.ir.types.PointerType'> i64*>,)
declare i64 @"putbool"(i64* %".1") 

(<<class 'llvmlite.ir.types.PointerType'> i64*>,)
declare i64 @"putinteger"(i64* %".1") 

(<<class 'llvmlite.ir.types.PointerType'> double*>,)
declare i64 @"putfloat"(double* %".1") 

(<<class 'llvmlite.ir.types.PointerType'> [256 x i8]*>,)
declare i64 @"putstring"([256 x i8]* %".1") 

(<<class 'llvmlite.ir.types.PointerType'> double*>,)
declare double @"sqrtt"(double* %".1") 

(<<class 'llvmlite.ir.types.PointerType'> [256 x i8]*>, <<class 'llvmlite.ir.types.PointerType'> [256 x i8]*>)
declare i64 @"strcomp"([256 x i8]* %".1", [256 x i8]* %".2") 

expanding program
expanding program header
returning: (Keyword,program)
returning: (Identifier,grant)
returning: (Keyword,is)
expanding program body
returning: (Keyword,global)
expanding declaration
returning: (Keyword,variable)
expanding variable declaration
returning: (Identifier,jake)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
returning: (Keyword,global)
expanding declaration
returning: (Keyword,variable)
expanding variable declaration
returning: (Identifier,ryan)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Bracket,[)
returning: (Digit,3)
returning: (Bracket,])
returning: (Semicolon,;)
returning: (Keyword,global)
expanding declaration
returning: (Keyword,variable)
expanding variable declaration
returning: (Identifier,zach)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,tmp)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
returning: (Keyword,procedure)
expanding declaration
expanding procedure declaration
expanding procedure header
returning: (Identifier,if_proc)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Paren,()
returning: (Paren,))
()
expanding procedure body
returning: (Keyword,variable)
('Keyword', 'variable')
expanding declaration
expanding variable declaration
returning: (Identifier,declaration)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
('Semicolon', ';')
returning: (Keyword,begin)
FOUND THE PROCEDURE BEGIN
returning: (Keyword,if)
expanding statement
('Keyword', 'if')
expanding if statement
returning: (Paren,()
expanding expression
returning: (Keyword,true)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Keyword', 'true')
acceptable: bool
type in factor: bool
AT THE END OF FACTOR, val= 
i64 1
returning: (Paren,))
value in term after factor is ('Paren', ')')
bool
value in relation after term is ('Paren', ')')
bool
value in arithop after relation is ('Paren', ')')
val in expression after arithOp is i64 1 bool
bool
returning: (Keyword,then)
expanding statement
returning: (Identifier,jake)
('Identifier', 'jake')
expanding assignment statement
expanding destination
returning: (Assignment,:=)
('Assignment', ':=')
expanding expression
returning: (Identifier,jake)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'jake')
name or procedure call?
expanding name or procedure
('Identifier', 'jake')
returning: (ArithOp,+)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.GlobalVariable 'jake' of type 'i64*'>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".4" = load i64, i64* @"jake"
value in term after factor is ('ArithOp', '+')
integer
value in relation after term is ('ArithOp', '+')
integer
value in arithop after relation is ('ArithOp', '+')
expanding arithOp
expanding relation
expanding term
expanding factor
returning: (Digit,1)
in factor ('Digit', '1')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 1
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
integer
value in relation after term is ('Semicolon', ';')
integer
value in arithop after relation is ('Semicolon', ';')
integer
<class 'NoneType'>
None
@"jake" = internal global i64 undef
ADDING IN ARITHOP
%".4" = load i64, i64* @"jake"
i64 1
val in expression after arithOp is %".5" = add i64 %".4", 1 integer
type in assignment_statement: integer
%".5" = add i64 %".4", 1
@"jake" = internal global i64 undef
returning: (Keyword,else)
returning: (Identifier,zach)
expanding statement
('Identifier', 'zach')
expanding assignment statement
expanding destination
returning: (Assignment,:=)
('Assignment', ':=')
expanding expression
returning: (Identifier,zach)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'zach')
name or procedure call?
expanding name or procedure
('Identifier', 'zach')
returning: (ArithOp,+)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.GlobalVariable 'zach' of type 'i64*'>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".8" = load i64, i64* @"zach"
value in term after factor is ('ArithOp', '+')
integer
value in relation after term is ('ArithOp', '+')
integer
value in arithop after relation is ('ArithOp', '+')
expanding arithOp
expanding relation
expanding term
expanding factor
returning: (Identifier,ryan)
in factor ('Identifier', 'ryan')
name or procedure call?
expanding name or procedure
('Identifier', 'ryan')
returning: (Bracket,[)
expanding name
expanding expression
returning: (Digit,2)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Digit', '2')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 2
returning: (Bracket,])
value in term after factor is ('Bracket', ']')
integer
value in relation after term is ('Bracket', ']')
integer
value in arithop after relation is ('Bracket', ']')
val in expression after arithOp is i64 2 integer
{'type': 'integer', 'bound': 3, 'procedure': False, 'val': <ir.GlobalVariable 'ryan' of type 'i64*'>}
PRINTING BOUNDVAL:  i64 2
@"ryan" = internal global i64 undef
