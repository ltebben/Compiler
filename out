i64
i64
float
[256 x i8]
i64
i64
float
[256 x i8]
float
expanding program
expanding program header
returning: (Keyword,program)
returning: (Identifier,test_program)
returning: (Keyword,is)
expanding program body
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,fibb_result)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,o)
returning: (Colon,:)
expanding type mark
returning: (Keyword,bool)
returning: (Semicolon,;)
returning: (Keyword,procedure)
expanding declaration
expanding procedure declaration
expanding procedure header
returning: (Identifier,fibb)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Paren,()
returning: (Keyword,variable)
expanding parameter list
expanding parameter
expanding variable declaration
returning: (Identifier,n)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Paren,))
n
(<ir.Argument '.1' of type i64>,)
expanding procedure body
returning: (Keyword,global)
('Keyword', 'global')
expanding declaration
returning: (Keyword,variable)
expanding variable declaration
returning: (Identifier,x)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
('Semicolon', ';')
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,y)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
('Semicolon', ';')
returning: (Keyword,variable)
expanding declaration
expanding variable declaration
returning: (Identifier,result)
returning: (Colon,:)
expanding type mark
returning: (Keyword,integer)
returning: (Semicolon,;)
('Semicolon', ';')
returning: (Keyword,begin)
FOUND THE PROCEDURE BEGIN
returning: (Keyword,if)
expanding statement
expanding if statement
returning: (Paren,()
expanding expression
returning: (Identifier,n)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'n')
name or procedure call?
expanding name or procedure
('Identifier', 'n')
returning: (Relation,<)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
i64 %".1"
value in term after factor is ('Relation', '<')
value in relation after term is ('Relation', '<')
expanding relation
expanding term
expanding factor
returning: (Digit,0)
in factor ('Digit', '0')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 0
returning: (Paren,))
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
returning: (Keyword,then)
expanding statement
returning: (Identifier,result)
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Digit,0)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Digit', '0')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 0
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}, {'n': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}, 'y': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}, 'result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}}]
%"result" = alloca i64
returning: (Keyword,return)
expanding statement
expanding return statement
expanding expression
returning: (Identifier,result)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'result')
name or procedure call?
expanding name or procedure
('Identifier', 'result')
returning: (Semicolon,;)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".6" = load i64, i64* %"result"
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
%".6" = load i64, i64* %"result"
returning: (Keyword,end)
('Keyword', 'end')
returning: (Keyword,if)
returning: (Semicolon,;)
returning: (Keyword,if)
expanding statement
expanding if statement
returning: (Paren,()
expanding expression
returning: (Identifier,n)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'n')
name or procedure call?
expanding name or procedure
('Identifier', 'n')
returning: (Identifier,==)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
i64 %".1"
value in term after factor is ('Identifier', '==')
value in relation after term is ('Identifier', '==')
expanding relation
expanding term
expanding factor
returning: (Digit,0)
in factor ('Digit', '0')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 0
returning: (Paren,))
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
returning: (Keyword,then)
expanding statement
returning: (Identifier,result)
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Digit,0)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Digit', '0')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 0
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}, {'n': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}, 'y': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}, 'result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}}]
%"result" = alloca i64
returning: (Keyword,return)
expanding statement
expanding return statement
expanding expression
returning: (Identifier,result)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'result')
name or procedure call?
expanding name or procedure
('Identifier', 'result')
returning: (Semicolon,;)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".12" = load i64, i64* %"result"
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
%".12" = load i64, i64* %"result"
returning: (Keyword,end)
('Keyword', 'end')
returning: (Keyword,if)
returning: (Semicolon,;)
returning: (Keyword,if)
expanding statement
expanding if statement
returning: (Paren,()
expanding expression
returning: (Identifier,n)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'n')
name or procedure call?
expanding name or procedure
('Identifier', 'n')
returning: (Identifier,==)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
i64 %".1"
value in term after factor is ('Identifier', '==')
value in relation after term is ('Identifier', '==')
expanding relation
expanding term
expanding factor
returning: (Digit,1)
in factor ('Digit', '1')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 1
returning: (Paren,))
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
returning: (Keyword,then)
expanding statement
returning: (Identifier,result)
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Digit,1)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Digit', '1')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 1
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}, {'n': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}, 'y': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}, 'result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}}]
%"result" = alloca i64
returning: (Keyword,return)
expanding statement
expanding return statement
expanding expression
returning: (Identifier,result)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'result')
name or procedure call?
expanding name or procedure
('Identifier', 'result')
returning: (Semicolon,;)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".18" = load i64, i64* %"result"
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
%".18" = load i64, i64* %"result"
returning: (Keyword,end)
('Keyword', 'end')
returning: (Keyword,if)
returning: (Semicolon,;)
returning: (Identifier,x)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,fibb)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'fibb')
name or procedure call?
expanding name or procedure
('Identifier', 'fibb')
returning: (Paren,()
expanding procedure call
in expand procedure call:  ('Paren', '(')
returning: (Identifier,n)
expanding argument list
expanding expression
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'n')
name or procedure call?
expanding name or procedure
('Identifier', 'n')
returning: (ArithOp,-)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
i64 %".1"
value in term after factor is ('ArithOp', '-')
value in relation after term is ('ArithOp', '-')
value in arithop after relation is ('ArithOp', '-')
expanding arithOp
expanding relation
expanding term
expanding factor
returning: (Digit,1)
in factor ('Digit', '1')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 1
returning: (Paren,))
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
val in argument list after expression ('Paren', ')')
Here I am right before the die
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".22" = call i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 %".21")
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}, {'n': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}, 'y': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}, 'result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}}]
%"x" = alloca i64
returning: (Identifier,y)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,fibb)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'fibb')
name or procedure call?
expanding name or procedure
('Identifier', 'fibb')
returning: (Paren,()
expanding procedure call
in expand procedure call:  ('Paren', '(')
returning: (Identifier,n)
expanding argument list
expanding expression
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'n')
name or procedure call?
expanding name or procedure
('Identifier', 'n')
returning: (ArithOp,-)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
i64 %".1"
value in term after factor is ('ArithOp', '-')
value in relation after term is ('ArithOp', '-')
value in arithop after relation is ('ArithOp', '-')
expanding arithOp
expanding relation
expanding term
expanding factor
returning: (Digit,2)
in factor ('Digit', '2')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 2
returning: (Paren,))
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
val in argument list after expression ('Paren', ')')
Here I am right before the die
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".25" = call i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 %".24")
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}, {'n': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}, 'y': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}, 'result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}}]
%"y" = alloca i64
returning: (Identifier,result)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,x)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'x')
name or procedure call?
expanding name or procedure
('Identifier', 'x')
returning: (ArithOp,+)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".27" = load i64, i64* %"x"
value in term after factor is ('ArithOp', '+')
value in relation after term is ('ArithOp', '+')
value in arithop after relation is ('ArithOp', '+')
expanding arithOp
expanding relation
expanding term
expanding factor
returning: (Identifier,y)
in factor ('Identifier', 'y')
name or procedure call?
expanding name or procedure
('Identifier', 'y')
returning: (Semicolon,;)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".28" = load i64, i64* %"y"
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
ADDING IN ARITHOP
%".27" = load i64, i64* %"x"
%".28" = load i64, i64* %"y"
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}, {'n': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.Argument '.1' of type i64>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}, 'y': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'y' of type 'i64*', opname 'alloca', operands ()>}, 'result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}}]
%"result" = alloca i64
returning: (Keyword,return)
expanding statement
expanding return statement
expanding expression
returning: (Identifier,result)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'result')
name or procedure call?
expanding name or procedure
('Identifier', 'result')
returning: (Semicolon,;)
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'result' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".31" = load i64, i64* %"result"
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
%".31" = load i64, i64* %"result"
returning: (Keyword,end)
FOUND THE PROCEDURE END
returning: (Keyword,procedure)
RETURN CONTROL TO PROGRAM
returning: (Semicolon,;)
returning: (Keyword,begin)
MOVING ON TO PROGRAM CODE FINALLY
returning: (Identifier,fibb_result)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,fibb)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'fibb')
name or procedure call?
expanding name or procedure
('Identifier', 'fibb')
returning: (Paren,()
expanding procedure call
in expand procedure call:  ('Paren', '(')
returning: (Digit,12)
expanding argument list
expanding expression
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Digit', '12')
acceptable: digit
type in factor: integer
AT THE END OF FACTOR, val= 
i64 12
returning: (Paren,))
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
val in argument list after expression ('Paren', ')')
Here I am right before the die
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".2" = call i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 12)
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: integer
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}]
%"fibb_result" = alloca i64
Back in program body, tmp is ('Semicolon', ';')
returning: (Identifier,o)
expanding statement
expanding assignment statement
expanding destination
returning: (Assignment,:=)
expanding expression
returning: (Identifier,putinteger)
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'putinteger')
name or procedure call?
expanding name or procedure
('Identifier', 'putinteger')
returning: (Paren,()
expanding procedure call
in expand procedure call:  ('Paren', '(')
returning: (Identifier,fibb_result)
expanding argument list
expanding expression
expanding arithOp
expanding relation
expanding term
expanding factor
in factor ('Identifier', 'fibb_result')
name or procedure call?
expanding name or procedure
('Identifier', 'fibb_result')
returning: (Paren,))
expanding name
{'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}
type in name_or_procedure: integer
type in factor: integer
AT THE END OF FACTOR, val= 
%".4" = load i64, i64* %"fibb_result"
value in term after factor is ('Paren', ')')
value in relation after term is ('Paren', ')')
value in arithop after relation is ('Paren', ')')
val in argument list after expression ('Paren', ')')
Here I am right before the die
type in name_or_procedure: bool
type in factor: bool
AT THE END OF FACTOR, val= 
%".5" = call i64 @"putinteger"(i64 %".4")
returning: (Semicolon,;)
value in term after factor is ('Semicolon', ';')
value in relation after term is ('Semicolon', ';')
value in arithop after relation is ('Semicolon', ';')
type in assignment_statement: bool
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}]
%"o" = alloca i64
Back in program body, tmp is ('Semicolon', ';')
returning: (Keyword,end)
returning: (Keyword,program)
returning: (Period,.)
returning: (EOF,eof)
[{'getbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'getbool' of type 'i64 (i64)*'>}, 'getinteger': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function 'getinteger' of type 'i64 (i64)*'>}, 'getfloat': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'getfloat' of type 'float (float)*'>}, 'getstring': {'type': 'string', 'bound': None, 'procedure': True, 'val': <ir.Function 'getstring' of type '[256 x i8] ([256 x i8])*'>}, 'putbool': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putbool' of type 'i64 (i64)*'>}, 'putinteger': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putinteger' of type 'i64 (i64)*'>}, 'putfloat': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putfloat' of type 'i64 (float)*'>}, 'putstring': {'type': 'bool', 'bound': None, 'procedure': True, 'val': <ir.Function 'putstring' of type 'i64 ([256 x i8])*'>}, 'sqrt': {'type': 'float', 'bound': None, 'procedure': True, 'val': <ir.Function 'sqrt' of type 'float (float)*'>}, 'x': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'x' of type 'i64*', opname 'alloca', operands ()>}}, {'fibb_result': {'type': 'integer', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'fibb_result' of type 'i64*', opname 'alloca', operands ()>}, 'o': {'type': 'bool', 'bound': None, 'procedure': False, 'val': <ir.AllocaInstr 'o' of type 'i64*', opname 'alloca', operands ()>}, 'fibb': {'type': 'integer', 'bound': None, 'procedure': True, 'val': <ir.Function '185c0fe7-16b5-4e55-b2b9-e4b151646605' of type 'i64 (i64)*'>}}]
; ModuleID = "program"
target triple = "unknown-unknown-unknown"
target datalayout = ""

declare i64 @"getbool"(i64 %".1") 

declare i64 @"getinteger"(i64 %".1") 

declare float @"getfloat"(float %".1") 

declare [256 x i8] @"getstring"([256 x i8] %".1") 

declare i64 @"putbool"(i64 %".1") 

declare i64 @"putinteger"(i64 %".1") 

declare i64 @"putfloat"(float %".1") 

declare i64 @"putstring"([256 x i8] %".1") 

declare float @"sqrt"(float %".1") 

define i64 @"main_function"() 
{
main_entry:
  %"fibb_result" = alloca i64
  %"o" = alloca i64
  %".2" = call i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 12)
  store i64 %".2", i64* %"fibb_result"
  %".4" = load i64, i64* %"fibb_result"
  %".5" = call i64 @"putinteger"(i64 %".4")
  store i64 %".5", i64* %"o"
  ret i64 1
}

define i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 %".1") 
{
function_entry:
  %"x" = alloca i64
  %"y" = alloca i64
  %"result" = alloca i64
  %".3" = icmp slt i64 %".1", 0
  br i1 %".3", label %"function_entry.if", label %"function_entry.else"
function_entry.if:
  store i64 0, i64* %"result"
  %".6" = load i64, i64* %"result"
  ret i64 %".6"
function_entry.else:
  br label %"function_entry.endif"
function_entry.endif:
  %".9" = icmp eq i64 %".1", 0
  br i1 %".9", label %"function_entry.endif.if", label %"function_entry.endif.else"
function_entry.endif.if:
  store i64 0, i64* %"result"
  %".12" = load i64, i64* %"result"
  ret i64 %".12"
function_entry.endif.else:
  br label %"function_entry.endif.endif"
function_entry.endif.endif:
  %".15" = icmp eq i64 %".1", 1
  br i1 %".15", label %"function_entry.endif.endif.if", label %"function_entry.endif.endif.else"
function_entry.endif.endif.if:
  store i64 1, i64* %"result"
  %".18" = load i64, i64* %"result"
  ret i64 %".18"
function_entry.endif.endif.else:
  br label %"function_entry.endif.endif.endif"
function_entry.endif.endif.endif:
  %".21" = sub i64 %".1", 1
  %".22" = call i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 %".21")
  store i64 %".22", i64* %"x"
  %".24" = sub i64 %".1", 2
  %".25" = call i64 @"185c0fe7-16b5-4e55-b2b9-e4b151646605"(i64 %".24")
  store i64 %".25", i64* %"y"
  %".27" = load i64, i64* %"x"
  %".28" = load i64, i64* %"y"
  %".29" = add i64 %".27", %".28"
  store i64 %".29", i64* %"result"
  %".31" = load i64, i64* %"result"
  ret i64 %".31"
}

RES: 1
144
